# zetti ssg basics and extras

- [zetti ssg basics and extras](#zetti-ssg-basics-and-extras)
  - [Generate or update 'sitemapRaw.txt'](#generate-or-update-sitemaprawtxt)
  - [Check and convert wikilinks](#check-and-convert-wikilinks)
  - [Generate 'sitemap.txt' for SEO](#generate-sitemaptxt-for-seo)
  - [Generate the 'search.txt' file for search](#generate-the-searchtxt-file-for-search)
  - [Generate the 'sitesearch.txt' file for bm25 search](#generate-the-sitesearchtxt-file-for-bm25-search)


## Generate or update 'sitemapRaw.txt' 

'SitemapRaw.txt' lists all files that will appear in the folder/file list. It excludes files (like 'sitemapRaw.txt' itself) which should not appear in the list.

```js node //recursively generate/update list of files to sitemapRaw.txt
const path = require("path");
const fs   = require("fs");
let files  = [];
function readDir(dir) {
  let dirf=fs.readdirSync(dir);
  for (let dirs of [true,false]) //do directories first
    dirf.forEach(f => {
      if (!(f.startsWith('.') || f.indexOf('_files')==0)) {
      const fullpath = path.join(dir, f);
      if (dirs && fs.statSync(fullpath).isDirectory()) {
        if (f=='lib') return; //skip lib folder
        return readDir(fullpath); //recurse
      } else if (!dirs) {  //skip certain files so they don't appear when browsing the site
          if ( ['easymde.html','generator.md','index.html','manifest.json','network.html','sitemap.txt','sitemapRaw.txt', 'sitesearch.txt',
		        'stackedit.html','sw.js','tinymde.html','workbox-config.js'].includes(f) ) return;
          if(f.endsWith('.md') || f.endsWith('.html') || f.endsWith('.htm') || f.endsWith('.pdf') || f.endsWith('.txt') || f.endsWith('.jpg') || f.endsWith('.jpeg') || f.endsWith('.png') || f.endsWith('.gif'))
              return files.push(fullpath);
      }}
    })
}
readDir("./");
files.forEach((f,i)=>files[i]=f.replace(/\\/g,'/')); //change to forward slashes
let s="";
files.forEach(f => s+=f+'\n')
fs.writeFile("sitemapRaw.txt",s,(err)=>{ if (err) console.log(err); })
console.log('ok - sitemapRaw.txt saved');
```

## Check and convert wikilinks

```js node //check wikilinks [[abc]] with [[full/path/to/abc|abc]]
//can overwrite before deploying the site to save checking wikilinks when a page is loaded (uncomment writefile)
const fs   = require("fs");
let files=(''+fs.readFileSync('sitemapRaw.txt')).split('\n');
// files=['test.md']; //uncomment for a test
files.forEach(f => {
    if (f.endsWith('.md')){
    let t=''+fs.readFileSync(f);
    let re = /\[\[(.*?)]]/g,m;
    let changes=false;
    let tlist='';
    while (m = re.exec(t)) {
      let s = m[1], s1 = '', s2 = '';
      if (s.indexOf('|') > 0) [s,s2]=s.split('|');
      if (s.indexOf('.') < 0) s += '.md';
      s=s.toLowerCase();
      for (i = 0; i < files.length; i++) { //include all matching links
        if (files[i].toLowerCase().endsWith(s)) {
          if (s1 != '') s1 += '&';
          if (s2 == '') s2 = files[i].substring(files[i].lastIndexOf('/') + 1);
          if (s2.includes('.')) s2 = s2.substring(0, s2.indexOf('.'))
          s1 += '[[' + files[i] + '|' + s2 + ']]';
        }
      }
      if (s1 != '') {
        t = t.substring(0, re.lastIndex - m[0].length) + s1 + t.substring(re.lastIndex);
        re.lastIndex += s1.length - m[0].length;
        if ( m[0] != s1 ) {
          changes=true;
          tlist+='\n> '+s+' > '+s1;
        }
      }
    }
    if ( changes ) console.log(f,tlist);
    //fs.writeFileSync(f,t); //uncomment this to overwrite the original file(s)
}})
console.log('ok');
```

```js node //check italicised links
const fs   = require("fs");
let files=(''+fs.readFileSync('sitemapRaw.txt')).split('\n');
files.forEach(f => {
    if (f.endsWith('.md')){
    console.log(f);
    let t=''+fs.readFileSync(f);
    // let re = /\[\[(.*?)]]/g,m;
    let re = /\*\[(.*?)\]\*/g,m;
    while (m = re.exec(t)) {
        console.log('> '+m[1]);
    }
    //fs.writeFileSync(f,t);
}})
console.log('ok');
```

## Generate or update network.html to produce site network graphs


```js node //generate network.html to produce site network graphs
//this uses sitemapRaw.txt (generated by prevous codeblock) & searches each markdown file for links
const fs   = require("fs");
let files=(''+fs.readFileSync('sitemapRaw.txt')).split('\n');
//get markdown file names
let a=[],mdf=[],mdftest=[];
files.forEach(f => {
  if(f.endsWith('.md')) {
      mdf.push(f);
      mdftest.push(f.substring(0,f.length-3).toLowerCase());
    }
});
//get nodes = markdown files, edges = links, & groups/colours = path depth
let g='', iig=0, ig=0;
function group(a){ //generate groups as path depth
    if (a.substring(0,a.indexOf('/'))=='') {g='/';ig=0;}
    else if (a.substring(0,a.indexOf('/',a.indexOf('/')+1))==''){
        if (g==a.substring(0,a.indexOf('/'))){ig=iig;}
        else {g=a.substring(0,a.indexOf('/'));ig=++iig;}
    } else {
        if (g==a.substring(0,a.indexOf('/',a.indexOf('/')+1))){ig=iig;}
        else {g=a.substring(0,a.indexOf('/',a.indexOf('/')+1));ig=++iig;}
    }
    return ig;
}
let edges='[', nodes='[', nedges=0, mults=0;
for (let i=0;i<mdf.length;i++) { //for each markdown file
  //append node
  let f=mdf[i];
  nodes+='{ id: '+i+', label: "'+f.substring(f.lastIndexOf('/')+1,f.indexOf('.md'))+'", group: '+group(f)+', title: "'+f+'"  },\n';
  let text=fs.readFileSync(f);
  let temp=[];
  function findLinks(test){
    test=test.trim().toLowerCase();
    if(test.startsWith('http')) return; //skip if http
    test=test.replace(/%20/g,' ')
    // test=test.substring(test.lastIndexOf('/')+1);
    let multiple=false;
    for (let j=0;j<mdf.length;j++) {
        if(mdftest[j]==test || mdftest[j].endsWith('/'+test)) { //look for files which match link
            edges+='{ from: '+i+', to: '+j+' },\n';nedges++;
            if (multiple) mults++;
            else multiple=true;
            // break; //break here for first match only
        }
    } 
  }
  let re=/\[\[([\w\s/.-]*?)(\.md)?(\|.*)?\]\]/g; //re to find wikilinks, .md not needed for test
  while ((temp=re.exec(text))!=null) { findLinks(temp[1]); }
  re=/\]\(<?([^)]*?)\.md/g; //re to find markdown links to .md only
  while ((temp=re.exec(text))!=null) { findLinks(temp[1]); }
}
nodes+=']';edges+=']';
let html=`<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="./lib/zetti.css">
<style>.vis-tooltip { position: absolute;}
</style><!-- this enables showing title on hover -->
</head>
<body>
<span style="position:absolute; top:0; right:0; z-index:1;">
  <button title="more" onclick="ndepth++;subsetNodes();draw();" class="btn">+</button>
  <button title="less" onclick="ndepth--;if(ndepth==0)ndepth=1;subsetNodes();draw();" class="btn">-</button>
</span>
<div id="mynetwork" style="position:absolute;width: 100%; height: 100%;"></div>
<script src="./lib/vis-network.min.js"></script>
<script>
let param=''+window.location;
if (param.indexOf('?')<0) param='index.md';
else param=param.substring(param.indexOf('?')+6).replace(/%20/g,' ');
param=param.toLowerCase();
// if(parent.ifid=='peek2') document.getElementById('btnnet').style.display='none';
let ndepth=1;
var allNodes=${nodes};
var edges=${edges};
function getNodes(nodes1) { // get nodes connected to the nodes in nodes1
    function unique(value, index, self) { return self.indexOf(value) === index; }
    let nodes2=[];
    for (let n of nodes1) {
      nodes2.push(n);
      for (let e of edges) {
        if (e.from == n) { nodes2.push(e.to); }
        else if (e.to == n) { nodes2.push(e.from); }
      }
    }
    return nodes2.filter(unique).sort(function(a, b) {return a-b;});
}
let nodeNumsOrig=[];
if (param!='' && param.endsWith('.md')) { //param is the file name
    for (let i=0;i<allNodes.length;i++){
        if (allNodes[i].title.toLowerCase()==param) { nodeNumsOrig.push(i); }
    }
}
if (!param.endsWith('.md') || getNodes(nodeNumsOrig).length<=1) { 
      param=param.substring(0,param.lastIndexOf('/'));
      for (let i=0;i<allNodes.length;i++){ //if not markdown or only 1 node, get other nodes in same folder
        if (allNodes[i].title.substring(0,allNodes[i].title.lastIndexOf('/')).toLowerCase()==param) { nodeNumsOrig.push(i); }
      }
      ndepth=1;
}
function subsetNodes() {
    let nodeNums=[...nodeNumsOrig];
    for (let i=1;i<=ndepth;i++) nodeNums=[...getNodes(nodeNums)];
    let nodes=[...allNodes];
    for (let i=0;i<nodes.length;i++){ //draw orig node(s) square
      if (nodeNumsOrig.indexOf(i)>=0) {nodes[i].shape="square";nodes[i].size=25;nodes[i].group=255;}
    }
    for (let i=nodes.length-1;i>=0;i--){ //remove nodes not in nodeNums
      if (nodeNums.indexOf(i)<0)nodes.splice(i,1);
    }
    return nodes;
}
function draw() {
  if (parent.usedark) {
    document.body.style.backgroundColor = "#111";
    document.styleSheets[0].insertRule(".vis-tooltip { color: white;}", 0);
  } else document.body.style.backgroundColor = "#eee";
  // create a network
  var container = document.getElementById("mynetwork");
  let nodes1=new vis.DataSet(subsetNodes());
  let edges1=new vis.DataSet(edges);
  var data = {
    nodes: nodes1,
    edges: edges1,
  };
  var options = {
    nodes: {
      shape: "dot",
      size: 16,
      font: {color: color()},
    },
    edges: {
      arrows: "to",
    },
    interaction: {hover: true, hoverConnectedEdges:true, tooltipDelay: 300,},
    physics: {
      forceAtlas2Based: {
        gravitationalConstant: -26,
        centralGravity: 0.005,
        springLength: 230,
        springConstant: 0.18,
      },
      maxVelocity: 146,
      solver: "forceAtlas2Based",
      timestep: 0.35,
      stabilization: { iterations: 150 },
    },
  };
  var network = new vis.Network(container, data, options);
  network.on('click',function(properties){ 
    if(properties.nodes.length>0  && getNodes([properties.nodes[0]]).length>1){
      ndepth=1; //reset depth for quick response
      let temp=allNodes[properties.nodes[0]].label.replace(/%20/g,' ');
      let temp2=window.parent.hroot+'?file='+allNodes[properties.nodes[0]].title;
      parent.window.history.pushState({},"",parent.window.location.href);
      parent.hfile = allNodes[properties.nodes[0]].title;
      parent.loadfile(parent.hfile,parent.main,false);
      nodeNumsOrig=[properties.nodes[0]];subsetNodes();draw();
    } 
  });
}
function color() {
  if (parent.usedark) return '#ffffff';
  else return '#000000';
}
window.addEventListener("load", () => { if (window.innerWidth!=0) draw(); });
window.addEventListener("resize", () => { if (window.innerWidth!=0) draw(); });
</script></body></html>` //in network.on statement above, \x60 is ` & \x24 is $
fs.writeFile("network.html",html,(err)=>{ if (err) console.log(err); })
console.log('ok - network.html saved: '+mdf.length+','+nedges+','+mults);
```

## Generate 'sitemap.txt' for SEO

```js node //to produce sitemap.txt for SEO
//enter the site url below (example shown) and run this code
//note that this is just for SEO, sitemapRaw.txt is used for index.html
siteUrl='https://whatamigoingtodonow.net/starter/';
const fs   = require("fs");
let files=(''+fs.readFileSync('sitemapRaw.txt')).split('\n');
let s='';
files.forEach(f => {
  if(f.endsWith('.md')) s+=siteUrl+'index.html?file='+f+'\n';
  else if(f!='') s+=siteUrl+f+'\n';
});
fs.writeFile("sitemap.txt",s,(err)=>{ if (err) console.log(err); })
console.log('ok');
```

## Generate the 'sitsearch.txt' file for search

```js node //generate search.txt file for search
//produce file with combined text of all .md & .txt files for search etc
let t=new Date().getTime()
const fs   = require("fs");
let files=(''+fs.readFileSync('sitemapRaw.txt')).split('\n');
let s='';
files.forEach((f,i) => {
  if(f.endsWith('.md') || f.endsWith('.txt')) {
    let t=(''+fs.readFileSync(f)).split('\n');
    t.forEach((line,j) =>{s+=line=''+i+' '+(j+1)+': '+line+'\n';})
    // t=t.replace(/^/mg,''+i+' ');
    //s+=t.join('\n');
  }
});
fs.writeFile("sitesearch.txt",s,(err)=>{ if (err) console.log(err); })
console.log('done in '+(new Date().getTime()-t)/1000+' sec')
```

## Generate the json data for bm25 search if used

```js node //generate sitesearch.txt file for search (only needed if using bm25 search)
// produce json data with combined text of .md & .txt files for search etc
// format is { "title":"filename","body","file content (no quotes and \\n for \n)"},{etc..}
// & insert data into /bm25/bundle.js
let t=new Date().getTime()
const fs   = require("fs");
let files=(''+fs.readFileSync('sitemapRaw.txt')).split('\n');
let s='[';let i=0;
files.forEach((f,i) => {
  if(f.endsWith('.md') || f.endsWith('.txt')) {
    s+='{"title":"'+f+'","body":"';
    let t=(''+fs.readFileSync(f)).split('\n');
    t.forEach((line,j) =>{
      line=line.replace(/[^A-Za-z0-9 ,.]+/g,' ');
      s+=''+j+':'+line+'<br>';
    })
    s+='"},';
  }
});
s+=']';
let bundle=''+fs.readFileSync('bm25/bundle.js')
bundle=bundle.replace(/start json data[\s\S]*end json data/,'start json data\n'+s+'\n//end json data')
fs.writeFile("bm25/bundle.js",bundle,(err)=>{ if (err) console.log(err); })
console.log('done in '+(new Date().getTime()-t)/1000+' sec')
```

```js //original data in bm25 bundle
const fs   = require("fs");
let s=''+fs.readFileSync('/extras/bm25/test.json')
let bundle=''+fs.readFileSync('bm25/bundle.js')
bundle=bundle.replace(/start json data[\s\S]*end json data/,'start json data\n'+s+'\n//end json data')
fs.writeFile("bm25/bundle.js",bundle,(err)=>{ if (err) console.log(err); })
console.log('ok')
```


