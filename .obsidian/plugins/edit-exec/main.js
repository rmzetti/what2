/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EditExec
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var cp = __toESM(require("child_process"));
var fs = __toESM(require("fs"));
var process = __toESM(require("process"));
var os = __toESM(require("os"));
var EditExec = class extends import_obsidian.Plugin {
  //this.status.setText('text') sets statusbar text
  constructor(app, plugin) {
    super(app, plugin);
    this.status = this.addStatusBarItem();
    this.init = this.init.bind(this);
    this.app = app;
  }
  async onload() {
    this.addSettingTab(new SettingTab(this.app, this));
    this.addCommand({
      id: "editor-exec",
      name: "exec",
      callback: this.init,
      hotkeys: []
    });
    this.addCommand({
      id: "editor-delete",
      name: "delete output block",
      callback: () => this.init("del"),
      hotkeys: []
    });
  }
  async init(typ = "", lineToStart) {
    const currentView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!(currentView instanceof import_obsidian.MarkdownView)) {
      return;
    }
    const mdDoc = this.md = currentView.editor;
    const curNum = lineToStart || mdDoc.getCursor().line;
    const content2 = mdDoc.getValue();
    if (lineToStart) {
      mdDoc.setCursor(lineToStart ? lineToStart - 1 : 0);
    }
    const formatted = content2.split("\n");
    const queries = getExecCommands(formatted);
    const currentQuery = getCommand(queries, curNum);
    if (typ === "del")
      currentQuery.command += "~";
    if (currentQuery.start <= curNum && currentQuery.end >= curNum)
      await this.execCodeBlock(currentQuery, formatted, currentView);
  }
  async execCodeBlock(query, content, view) {
    if (!query) {
      return Promise.resolve();
    }
    const newContent = this.md.getValue().split("\n");
    const lastLine = getLastLineToReplace(newContent, query);
    let ssrm = "";
    const quiet = query.command.endsWith("~");
    if (quiet)
      query.command = query.command.slice(0, -1);
    if (query.command === "output") {
      ssrm = "```\n" + query.codeblock.trim() + "\n```\n";
      if (!quiet)
        ssrm = "";
      view.editor.replaceRange(ssrm, { line: query.start, ch: 0 }, { line: lastLine, ch: 0 });
    } else if (query.command === "html") {
      const tempFile = ".temp_.html";
      const s = query.codeblock;
      new import_obsidian.Notice(s);
      fs.promises.writeFile(tempFile, s).then(() => {
        execShell(tempFile);
      });
    } else if (query.command === "js" || query.command === "javascript") {
      const code = `async function __main(){let __out='';` + query.codeblock.replace(/console\.log/g, '__out=__out+"\\n"+') + `;return __out}; __main()`;
      ssrm = await eval(code);
      if (quiet)
        ssrm = "";
      if (ssrm.length > 0)
        ssrm = "```output" + ssrm + "\n```\n";
      view.editor.replaceRange(ssrm, { line: query.end + 1, ch: 0 }, { line: lastLine, ch: 0 });
    } else if (query.command === "budd") {
      const tempFile = "" + os.tmpdir() + "/temp_.txt";
      fs.promises.writeFile(tempFile, query.codeblock).then(async () => {
        ssrm = await execShell("buddvs.exe " + tempFile);
        if (quiet)
          ssrm = "";
        if (ssrm && ssrm.length > 0) {
          view.editor.replaceRange("```output\n" + ssrm + "```\n", { line: query.end + 1, ch: 0 }, { line: lastLine, ch: 0 });
        }
      });
    } else if (query.command === "node") {
      const tempFile = "" + os.tmpdir() + "/temp_.js";
      fs.promises.writeFile(tempFile, query.codeblock).then(async () => {
        process.chdir(this.app.vault.adapter.basePath);
        ssrm = await execShell("node " + tempFile);
        if (quiet)
          ssrm = "";
        if (ssrm && ssrm.length > 0) {
          view.editor.replaceRange("```output\n" + ssrm + "```\n", { line: query.end + 1, ch: 0 }, { line: lastLine, ch: 0 });
        }
      });
    } else if (query.command === "cmd") {
      const tempFile = "" + os.tmpdir() + "/temp_.bat";
      fs.promises.writeFile(tempFile, query.codeblock).then(async () => {
        ssrm = await execShell(tempFile);
        if (quiet)
          ssrm = "";
        if (ssrm && ssrm.length > 0) {
          view.editor.replaceRange("```output\n" + ssrm + "```\n", { line: query.end + 1, ch: 0 }, { line: lastLine, ch: 0 });
        }
      });
    } else if (query.command === "pwsh") {
      const tempFile = "" + os.tmpdir() + "/temp_.ps1";
      fs.promises.writeFile(tempFile, query.codeblock).then(async () => {
        ssrm = await execShell("powershell.exe -ExecutionPolicy Bypass -File " + tempFile);
        if (quiet)
          ssrm = "";
        if (ssrm && ssrm.length > 0) {
          view.editor.replaceRange("```output\n" + ssrm + "```\n", { line: query.end + 1, ch: 0 }, { line: lastLine, ch: 0 });
        }
      });
    } else if (query.command === "bash") {
      const tempFile = "" + os.tmpdir() + "/temp_.sh";
      fs.promises.writeFile(tempFile, query.codeblock).then(async () => {
        ssrm = await execShell("bash.exe " + tempFile);
        if (quiet)
          ssrm = "";
        if (ssrm && ssrm.length > 0) {
          view.editor.replaceRange("```output\n" + ssrm + "```\n", { line: query.end + 1, ch: 0 }, { line: lastLine, ch: 0 });
        }
      });
    }
    return Promise.resolve();
  }
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.app = app;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Editor-execute plugin settings" });
  }
};
async function execShell(cmd) {
  return new Promise((resolve, reject) => {
    cp.exec(cmd, (err1, out1, stderr1) => {
      if (err1 && stderr1 !== "") {
        console.log(out1 + err1 + "," + stderr1);
        return resolve(out1 + err1 + "," + stderr1);
      }
      console.log("\n" + out1 + stderr1);
      return resolve(out1 + stderr1);
    });
  });
}
function getExecCommands(content2) {
  const accum = [];
  for (let i = 0; i < content2.length; i++) {
    let line = content2[i];
    const commands = ["js", "javascript", "output", "html", "budd", "cmd", "pwsh", "bash", "node"];
    if (line.startsWith("```")) {
      if (line.includes("budd")) {
        line = "budd";
      } else if (line.includes("node")) {
        line = "node";
      } else {
        line = content2[i].substring(3).replace(/[ :].*/, "").toLowerCase();
      }
      if (commands.includes(line)) {
        let codeblock = "";
        for (let e = 0; e < content2.length - i; e++) {
          const nextline = content2[i + e];
          if (nextline === "```") {
            accum.push(
              {
                start: i,
                end: i + e,
                query: content2[i + 1],
                command: line,
                codeblock
              }
            );
            break;
          } else {
            if (e > 0)
              codeblock += nextline + "\n";
          }
        }
      }
    } else if (line.startsWith("`")) {
      line = line.replace(/^[^`].*/, "").replace(/(`.*?`).*/, "$1").replace(/`(.*?)[\s:`].*/, "$1");
      if (commands.includes(line)) {
        const codeblock = content2[i].replace(/`.*?[\s:](.*?)`.*/g, "$1");
        accum.push(
          {
            start: i,
            end: i,
            query: codeblock,
            command: line,
            codeblock
          }
        );
      }
    }
  }
  return accum;
}
function getCommand(queries, lineNumber) {
  if (queries.length === 0) {
    return void 0;
  }
  for (let i = 0; i < queries.length; i++) {
    const query2 = queries[i];
    if (query2.start <= lineNumber && query2.end >= lineNumber) {
      return query2;
    }
  }
  return void 0;
}
function getLastLineToReplace(content2, query2) {
  const lineFrom = query2.end;
  let ireturn = lineFrom + 1;
  let out = false;
  if (content2[lineFrom + 1].replace(/\s/g, "") !== "") {
    for (let i = lineFrom + 1; i < content2.length; i++) {
      if (content2[i] === "```output" && i === lineFrom + 1)
        out = true;
      if (content2[i] === "```") {
        if (out)
          ireturn = i + 1;
        else
          ireturn = i;
        break;
      }
      if (!out && i === lineFrom + 1) {
        ireturn = i;
        break;
      }
    }
  }
  return ireturn;
}
async function inHere(s, content2) {
  const n = (s.match(/`include /g) || []).length;
  if (n === 0) {
    return s;
  }
  const re1 = new RegExp("^([\\s\\S]*?)`include(.*?)(#\\w*)`([\\s\\S]*)$", "m");
  for (let i = 0; i < n; i++) {
    const f = s.replace(re1, "$2").trim();
    let s1 = "";
    if (f === "") {
      s1 = content2;
    } else
      return s;
    const tag = s.replace(re1, "$3");
    if (tag === "#") {
      if (f === "") {
        s1 = "";
      }
    } else {
      const re = new RegExp("[\\s\\S]*?" + tag + "($[\\s\\S]*?)" + tag + "[\\s\\S]*", "m");
      s1 = s1.replace(re, "$1").trim();
    }
    if (/`include/.test(s1)) {
      s1 = await inHere(s1, content2);
    }
    s = s.replace(re1, "$1" + s1 + "$4");
  }
  return s;
}
